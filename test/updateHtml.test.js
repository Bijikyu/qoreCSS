/*
 * HTML UPDATE TESTING - DEPLOYMENT ASSET REFERENCE MANAGEMENT
 * 
 * PURPOSE AND RATIONALE:
 * This test suite validates the updateHtml script's ability to correctly modify
 * HTML files with current build hashes and CDN URLs. This functionality is
 * critical for deployment workflows where HTML must reference the exact CSS
 * files generated by the build process.
 * 
 * TESTING STRATEGY:
 * - Isolated temporary directories prevent test interference
 * - Realistic HTML templates test actual deployment scenarios
 * - Hash file integration validates build system coordination
 * - CDN URL templating confirms environment-specific configuration
 * 
 * This approach ensures HTML update operations work correctly across different
 * deployment scenarios while maintaining proper asset reference management.
 */

require("./helper"); // loads module stubbing for consistent test environment
const assert = require('node:assert'); // Node.js built-in assertion library for test validation
const fs = require('node:fs'); // file system operations for test setup and validation
const path = require('node:path'); // path utilities for cross-platform file handling
const os = require('node:os'); // operating system utilities for temporary directory creation
const {describe, it, beforeEach, afterEach} = require('node:test'); // Node.js native test framework components
const updateHtml = require('../scripts/updateHtml'); // imports updateHtml function for testing

let tmpDir; // temporary directory path for isolated test execution

/*
 * TEST SETUP CONFIGURATION
 * 
 * ISOLATION STRATEGY:
 * Each test runs in a fresh temporary directory with realistic build artifacts
 * including hash files and HTML templates. This setup mirrors actual deployment
 * conditions where updateHtml processes real build outputs.
 */
beforeEach(async () => {
  tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'htmltest-')); // creates unique temporary directory for test isolation
  fs.writeFileSync(path.join(tmpDir, 'build.hash'), '12345678'); // creates mock build hash file with test hash
  fs.writeFileSync(path.join(tmpDir, 'index.html'), '<link href="core.aaaaaaaa.min.css">\n{{CDN_BASE_URL}}'); // creates realistic HTML with hash placeholder and CDN template
  process.chdir(tmpDir); // changes working directory to temporary location for script execution
});

/*
 * TEST CLEANUP PROCEDURE
 * 
 * CLEANUP RATIONALE:
 * Restores original working directory and removes temporary files to prevent
 * test artifacts from accumulating and affecting subsequent test runs.
 * Proper cleanup ensures test environment consistency.
 */
afterEach(() => {
  process.chdir(path.resolve(__dirname, '..')); // restores original working directory
  fs.rmSync(tmpDir, {recursive: true, force: true}); // removes temporary directory and all contents
});

/*
 * HTML UPDATE FUNCTIONALITY VALIDATION
 * 
 * TESTING SCOPE:
 * Validates the complete HTML update workflow including hash injection and
 * CDN URL templating. These tests ensure the deployment pipeline produces
 * correctly configured HTML files that reference accurate build artifacts.
 */
describe('updateHtml', () => {
  /*
   * COMPREHENSIVE HTML UPDATE VALIDATION
   * 
   * TEST STRATEGY:
   * Executes updateHtml with environment CDN configuration and validates
   * both hash replacement and template substitution. This test confirms
   * the complete deployment asset reference workflow works correctly.
   */
  it('updates html with hash and CDN url', async () => {
    process.env.CDN_BASE_URL = 'http://testcdn'; // sets CDN environment variable for template replacement
    const hash = await updateHtml(); // executes HTML update and captures returned hash
    const updated = fs.readFileSync(path.join(tmpDir, 'index.html'), 'utf8'); // reads modified HTML for validation
    assert.ok(updated.includes('core.12345678.min.css')); // confirms hash was properly injected into CSS reference
    assert.ok(updated.includes('http://testcdn')); // confirms CDN URL template was properly replaced
    assert.strictEqual(hash, '12345678'); // validates function returns correct hash value
  });

  it('trims trailing slashes from CDN url', async () => {
    process.env.CDN_BASE_URL = 'http://testcdn///'; // sets CDN with extra slashes to test trimming
    const hash = await updateHtml(); // executes HTML update
    const updated = fs.readFileSync(path.join(tmpDir, 'index.html'), 'utf8'); // read updated HTML
    assert.ok(updated.includes('http://testcdn')); // confirm url normalized without trailing slashes
    assert.ok(!updated.includes('http://testcdn///')); // ensure extraneous slashes removed
    assert.strictEqual(hash, '12345678'); // hash remains unchanged
  });

  /*
   * EMPTY CDN URL VALIDATION
   *
   * TEST STRATEGY:
   * Ensures that when CDN_BASE_URL is set to an empty string the default
   * jsDelivr URL is inserted into HTML.
   */
  it('uses default CDN url when env value empty', async () => {
    process.env.CDN_BASE_URL = ''; // intentionally blank to test default fallback
    const hash = await updateHtml(); // execute update with blank CDN URL
    const updated = fs.readFileSync(path.join(tmpDir, 'index.html'), 'utf8'); // read updated HTML for verification
    assert.ok(updated.includes('https://cdn.jsdelivr.net')); // default should replace blank value
    assert.strictEqual(hash, '12345678'); // returned hash should remain correct
  });

  /*
   * FALLBACK CSS REPLACEMENT VALIDATION
   * 
   * TEST STRATEGY:
   * Tests the scenario where HTML contains plain qore.css references instead
   * of hashed placeholders. This validates the fallback replacement logic
   * that handles different HTML template patterns during deployment.
   */
  it('replaces qore.css when hash missing', async () => {
    fs.writeFileSync(path.join(tmpDir, 'index.html'), '<link href="qore.css">'); // setup html without placeholder hash references
    const hash = await updateHtml(); // run update on qore.css html to test fallback logic
    const updated = fs.readFileSync(path.join(tmpDir, 'index.html'), 'utf8'); // read modified html for validation
    assert.ok(updated.includes('core.12345678.min.css')); // verify qore.css was replaced with hashed filename
    assert.strictEqual(hash, '12345678'); // ensure returned hash unchanged from build.hash file
  });

  it('replaces core.min.css with hashed file', async () => {
    fs.writeFileSync(path.join(tmpDir, 'index.html'), '<link href="core.min.css">'); // setup html with non-hashed css reference
    const hash = await updateHtml(); // execute update to test core.min.css replacement
    const updated = fs.readFileSync(path.join(tmpDir, 'index.html'), 'utf8'); // read updated html for assertion
    assert.ok(updated.includes('core.12345678.min.css')); // ensure core.min.css updated to hashed filename
    assert.strictEqual(hash, '12345678'); // verify returned hash unchanged from build.hash file
  });

  /*
   * MIXED CSS REFERENCES VALIDATION
   *
   * TEST STRATEGY:
   * Validates that a file containing both qore.css and an outdated hashed file
   * is fully updated to the current hash in one replacement pass.
   */
  it('handles file with qore.css and old hashed reference', async () => {
    fs.writeFileSync(path.join(tmpDir, 'index.html'), '<link href="qore.css">\n<link href="core.deadbeef.min.css">'); // html with mixed css references
    const hash = await updateHtml(); // execute update on mixed html
    const updated = fs.readFileSync(path.join(tmpDir, 'index.html'), 'utf8'); // read result for validation
    const count = (updated.match(/core\.12345678\.min\.css/g) || []).length; // count occurrences of updated hash
    assert.strictEqual(count, 2); // both references should be replaced
    assert.strictEqual(hash, '12345678'); // returned hash remains correct
  });
  it('leaves gzipped reference unchanged', async () => {
    fs.writeFileSync(path.join(tmpDir, 'index.html'), '<link href="core.aaaaaaaa.min.css.gz">'); // gzipped css should remain as generated
    const hash = await updateHtml(); // execute update
    const updated = fs.readFileSync(path.join(tmpDir, 'index.html'), 'utf8'); // retrieve updated html
    assert.ok(updated.includes('core.aaaaaaaa.min.css.gz')); // verify compressed file kept same name
    assert.strictEqual(hash, '12345678'); // returned hash should be unchanged
  });


  it('writes file using utf8 encoding', async () => {
    let encOpt; // stores provided encoding option for assertion
    const origWrite = fs.promises.writeFile; // save original function for later restoration
    fs.promises.writeFile = async function(p, d, o){ encOpt = o; return origWrite.call(this, p, d, o); }; // intercepts call to capture encoding while executing original logic
    const hash = await updateHtml(); // run update to invoke writeFile
    fs.promises.writeFile = origWrite; // restore original writeFile to avoid cross-test pollution
    assert.strictEqual(encOpt, 'utf8'); // verify utf8 encoding explicitly passed
    assert.strictEqual(hash, '12345678'); // ensure function still returns correct hash
  });

  it('returns 1 when hash invalid', async () => {
    fs.writeFileSync(path.join(tmpDir, 'build.hash'), 'invalid'); // writes malformed hash for validation
    const original = fs.readFileSync(path.join(tmpDir, 'index.html'), 'utf8'); // save initial html for comparison
    const code = await updateHtml(); // execute update with invalid hash
    const updated = fs.readFileSync(path.join(tmpDir, 'index.html'), 'utf8'); // read file after attempt
    assert.strictEqual(code, 1); // function should signal failure via return code
    assert.strictEqual(updated, original); // html should remain unchanged on invalid hash
  });
});

// CLI exit code tests ensure process.exitCode reflects missing build artifacts
const {spawnSync} = require('node:child_process'); // child process used to run script directly

describe('updateHtml exit code', {concurrency:false}, () => {
  it('returns exit code 1 when build.hash missing via CLI', () => {
    fs.rmSync(path.join(tmpDir, 'build.hash')); // removes hash file to simulate missing artifact
    const result = spawnSync(process.execPath, [path.resolve(__dirname,'../scripts/updateHtml.js')], {cwd: tmpDir, env:{...process.env}}); // runs script in new process
    assert.strictEqual(result.status, 1); // validates process exited with code 1
  });
});

// Regression test ensures catch block safely handles errors without path property
describe('updateHtml regression', {concurrency:false}, () => {
  it('handles ENOENT error lacking path', async () => {
    fs.rmSync(path.join(tmpDir, 'build.hash')); // removes hash to trigger ENOENT
    const fsPromises = fs.promises; // alias for patching access function
    const origAccess = fsPromises.access; // preserve original implementation for restoration
    fsPromises.access = async () => { const e = new Error('missing'); e.code = 'ENOENT'; throw e; }; // stub access to throw without path
    await assert.rejects(
      async () => await updateHtml(), // run update expecting rejection from stubbed access
      err => err.code === 'ENOENT' // confirm error propagated without TypeError
    );
    fsPromises.access = origAccess; // restore original fs access to avoid cross-test effects
  });
});

