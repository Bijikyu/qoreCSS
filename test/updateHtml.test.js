/*
 * HTML UPDATE TESTING - DEPLOYMENT ASSET REFERENCE MANAGEMENT
 * 
 * PURPOSE AND RATIONALE:
 * This test suite validates the updateHtml script's ability to correctly modify
 * HTML files with current build hashes and CDN URLs. This functionality is
 * critical for deployment workflows where HTML must reference the exact CSS
 * files generated by the build process.
 * 
 * TESTING STRATEGY:
 * - Isolated temporary directories prevent test interference
 * - Realistic HTML templates test actual deployment scenarios
 * - Hash file integration validates build system coordination
 * - CDN URL templating confirms environment-specific configuration
 * 
 * This approach ensures HTML update operations work correctly across different
 * deployment scenarios while maintaining proper asset reference management.
 */

require("./helper"); // loads module stubbing for consistent test environment
const assert = require('node:assert'); // Node.js built-in assertion library for test validation
const fs = require('node:fs'); // file system operations for test setup and validation
const path = require('node:path'); // path utilities for cross-platform file handling
const os = require('node:os'); // operating system utilities for temporary directory creation
const {describe, it, beforeEach, afterEach} = require('node:test'); // Node.js native test framework components
const updateHtml = require('../scripts/updateHtml'); // imports updateHtml function for testing

let tmpDir; // temporary directory path for isolated test execution

/*
 * TEST SETUP CONFIGURATION
 * 
 * ISOLATION STRATEGY:
 * Each test runs in a fresh temporary directory with realistic build artifacts
 * including hash files and HTML templates. This setup mirrors actual deployment
 * conditions where updateHtml processes real build outputs.
 */
beforeEach(async () => {
  tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'htmltest-')); // creates unique temporary directory for test isolation
  fs.writeFileSync(path.join(tmpDir, 'build.hash'), '12345678'); // creates mock build hash file with test hash
  fs.writeFileSync(path.join(tmpDir, 'index.html'), '<link href="core.aaaaaaaa.min.css">\n{{CDN_BASE_URL}}'); // creates realistic HTML with hash placeholder and CDN template
  process.chdir(tmpDir); // changes working directory to temporary location for script execution
});

/*
 * TEST CLEANUP PROCEDURE
 * 
 * CLEANUP RATIONALE:
 * Restores original working directory and removes temporary files to prevent
 * test artifacts from accumulating and affecting subsequent test runs.
 * Proper cleanup ensures test environment consistency.
 */
afterEach(() => {
  process.chdir(path.resolve(__dirname, '..')); // restores original working directory
  fs.rmSync(tmpDir, {recursive: true, force: true}); // removes temporary directory and all contents
});

/*
 * HTML UPDATE FUNCTIONALITY VALIDATION
 * 
 * TESTING SCOPE:
 * Validates the complete HTML update workflow including hash injection and
 * CDN URL templating. These tests ensure the deployment pipeline produces
 * correctly configured HTML files that reference accurate build artifacts.
 */
describe('updateHtml', () => {
  /*
   * COMPREHENSIVE HTML UPDATE VALIDATION
   * 
   * TEST STRATEGY:
   * Executes updateHtml with environment CDN configuration and validates
   * both hash replacement and template substitution. This test confirms
   * the complete deployment asset reference workflow works correctly.
   */
  it('updates html with hash and CDN url', async () => {
    process.env.CDN_BASE_URL = 'http://testcdn'; // sets CDN environment variable for template replacement
    const hash = await updateHtml(); // executes HTML update and captures returned hash
    const updated = fs.readFileSync(path.join(tmpDir, 'index.html'), 'utf8'); // reads modified HTML for validation
    assert.ok(updated.includes('core.12345678.min.css')); // confirms hash was properly injected into CSS reference
    assert.ok(updated.includes('http://testcdn')); // confirms CDN URL template was properly replaced
    assert.strictEqual(hash, '12345678'); // validates function returns correct hash value
  });

  /*
   * FALLBACK CSS REPLACEMENT VALIDATION
   * 
   * TEST STRATEGY:
   * Tests the scenario where HTML contains plain qore.css references instead
   * of hashed placeholders. This validates the fallback replacement logic
   * that handles different HTML template patterns during deployment.
   */
  it('replaces qore.css when hash missing', async () => {
    fs.writeFileSync(path.join(tmpDir, 'index.html'), '<link href="qore.css">'); // setup html without placeholder hash references
    const hash = await updateHtml(); // run update on qore.css html to test fallback logic
    const updated = fs.readFileSync(path.join(tmpDir, 'index.html'), 'utf8'); // read modified html for validation
    assert.ok(updated.includes('core.12345678.min.css')); // verify qore.css was replaced with hashed filename
    assert.strictEqual(hash, '12345678'); // ensure returned hash unchanged from build.hash file
  });

  /*
   * MISSING BUILD HASH FILE VALIDATION
   *
   * TEST STRATEGY:
   * Removes build.hash to simulate missing build information and expects
   * updateHtml to return error code 1 indicating failure. This mirrors the
   * deployment script behavior when a build has not been run.
   */
  it('returns error code when build.hash missing', async () => {
    fs.rmSync(path.join(tmpDir, 'build.hash')); // removes hash file to trigger error
    const code = await updateHtml(); // executes html update expecting error return
    assert.strictEqual(code, 1); // verifies return code indicates missing file
  });

  /*
   * MISSING HTML FILE VALIDATION
   *
   * TEST STRATEGY:
   * Removes index.html to simulate deployment configuration errors and expects
   * updateHtml to throw ENOENT. The error path check ensures it identifies the
   * missing html file specifically.
   */
  it('throws when index.html missing', async () => {
    fs.rmSync(path.join(tmpDir, 'index.html')); // removes html file before update
    await assert.rejects(
      async () => await updateHtml(), // executes update expecting rejection
      err => err.code === 'ENOENT' && err.path.includes('index.html') // validates missing html error
    );
  });
});
